<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Devlog: 002 - Building Terraform Custom Types | Matthew Hartstonge</title>
<meta name=keywords content="DevOps,Go,Golang,Programming,SoftwareDevelopment,SoftwareEngineering,Terraform,PluginFramework,CustomTypes"><meta name=description content="Terraform Plugin Framework Custom Types One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.
One of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids."><meta name=author content="Matthew Hartstonge"><link rel=canonical href=https://blog.mykro.co.nz/posts/2023-07-22-devlog-002/><meta name=google-site-verification content="G-3N8ZQ0TS42"><link crossorigin=anonymous href=/assets/css/stylesheet.49e1a9d11d71e94986513bdf8be953c1be6edeee520b367d13aa6b887bafe4f5.css integrity="sha256-SeGp0R1x6UmGUTvfi+lTwb5u3u5SCzZ9E6priHuv5PU=" rel="preload stylesheet" as=style><link rel=icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=250"><link rel=icon type=image/png sizes=16x16 href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=16"><link rel=icon type=image/png sizes=32x32 href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=32"><link rel=apple-touch-icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=192"><link rel=mask-icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=64"><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.mykro.co.nz/posts/2023-07-22-devlog-002/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Devlog: 002 - Building Terraform Custom Types"><meta property="og:description" content="Terraform Plugin Framework Custom Types One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.
One of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mykro.co.nz/posts/2023-07-22-devlog-002/"><meta property="og:image" content="https://blog.mykro.co.nz/images/developing-terraform-provider-types.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-22T17:45:00+12:00"><meta property="article:modified_time" content="2023-07-22T17:45:00+12:00"><meta property="og:site_name" content="Matthew Hartstonge"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.mykro.co.nz/images/developing-terraform-provider-types.jpeg"><meta name=twitter:title content="Devlog: 002 - Building Terraform Custom Types"><meta name=twitter:description content="Terraform Plugin Framework Custom Types One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.
One of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.mykro.co.nz/posts/"},{"@type":"ListItem","position":2,"name":"Devlog: 002 - Building Terraform Custom Types","item":"https://blog.mykro.co.nz/posts/2023-07-22-devlog-002/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Devlog: 002 - Building Terraform Custom Types","name":"Devlog: 002 - Building Terraform Custom Types","description":"Terraform Plugin Framework Custom Types One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.\nOne of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids.","keywords":["DevOps","Go","Golang","Programming","SoftwareDevelopment","SoftwareEngineering","Terraform","PluginFramework","CustomTypes"],"articleBody":"Terraform Plugin Framework Custom Types One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.\nOne of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids. I quickly tried to reach for an equivalent UUID validator in the plugin framework. Unfortunately, the UUID validator hasn’t been brought across from SDKv2. Remembering the benefits the Plugin Framework was supposed to afford us, I started to dig into the custom types.\nWhen I initially dug into custom types, the Framework was only at v0.14.X and coming back to it almost a year later with the Framework having gone Generally Available (GA) with v1.X.X in February of 2023, there were several improvements and interfaces I needed to update my custom UUID type to use.\nSidenote: Shout out to Brian Flad (bflad) who initially created a custom type for time values while building out the Plugin Framework to see how the interface would look for implementors.\nInterface-Driven Design The Framework now provides a core-type system that can be extended, which makes a lot more sense and makes fantastic use of Go’s composability to reduce the amount of code required. Pre-v1.X.X types were simply tfsdk Attributes that would then take in your custom type:\n1 2 3 4 5 \"id\": tfsdk.Attribute{ Required: true, Type: uuidtypes.UUIDType{}, // Potentially previous Validators } But now custom types are extended from the Framework’s base types, which roughly match the underlying base types that Go (the programming language) provides, so my UUID Type now implements basetypes.StringTypable.\n1 2 3 4 5 \"id\": schema.StringAttribute{ CustomType: uuidtypes.UUIDType{}, Required: true, // ... }, Surprisingly, once I worked out the new interfaces that were required to implement a basetypes.StringTypable, I was able to remove a lot of my code and migrate the remaining methods to wrap the overloaded methods where my custom type (UUIDType or UUIDValue) was required to be specified.\nMaintenance Take the following method that implements the attr.Attribute interface that overloads Equal from the composed basetypes.StringType struct.\n1 2 3 4 5 6 7 8 9 // Equal returns true if the two types are equivalent. func (u UUIDType) Equal(o attr.Type) bool { other, ok := o.(UUIDType) if !ok { return false } return u.StringType.Equal(other.StringType) } While a trivial example of how the new Plugin Framework’s composition helps, this means that as the framework grows and new features and methods get added to the base String Type, the maintenance overhead required should be minimised as the base types will, hopefully in most cases, be able to implement upgraded functionality for us for free.\nRolling up from v0.14.X to v1.X.X, while expected, was a bit of a pain as I was developing on top of a beta framework with many underlying changes expected - Custom Types being one of the last features of the framework to get a look at. In truth, custom types weren’t documented and supported until Terraform Plugin Framework v1.3.X. The new documentation is fantastic, enabling a developer to easily integrate and extend the Plugin Framework.\nFollow Along Feel free to follow along with my development at GitHub or chat via my socials:\nGithub - matthewhartstonge/terraform-provider-fusionauth Github - matthewhartstonge/terraform-plugin-framework-type-uuid LinkedIn Twitter Addendum Time to Code: 6h Time to Blog: 1.5h ","wordCount":"576","inLanguage":"en","image":"https://blog.mykro.co.nz/images/developing-terraform-provider-types.jpeg","datePublished":"2023-07-22T17:45:00+12:00","dateModified":"2023-07-22T17:45:00+12:00","author":{"@type":"Person","name":"Matthew Hartstonge"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mykro.co.nz/posts/2023-07-22-devlog-002/"},"publisher":{"@type":"Organization","name":"Matthew Hartstonge","logo":{"@type":"ImageObject","url":"https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=250"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.mykro.co.nz/ accesskey=h title="Matthew Hartstonge (Alt + H)">Matthew Hartstonge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.mykro.co.nz/posts title=Blog><span>Blog</span></a></li><li><a href=https://blog.mykro.co.nz/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.mykro.co.nz/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Devlog: 002 - Building Terraform Custom Types</h1><div class=post-meta><span title='2023-07-22 17:45:00 +1200 NZST'>July 22, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;576 words&nbsp;·&nbsp;Matthew Hartstonge</div></header><figure class=entry-cover><img loading=eager src=https://blog.mykro.co.nz/images/developing-terraform-provider-types.jpeg alt="A cloud containing an open door showing gears inside, being tinkered at by an engineer wearing a hard hat against an abstract background of code"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#terraform-plugin-framework-custom-types>Terraform Plugin Framework Custom Types</a><ul><li><a href=#interface-driven-design>Interface-Driven Design</a></li><li><a href=#maintenance>Maintenance</a></li></ul></li><li><a href=#follow-along>Follow Along</a></li><li><a href=#addendum>Addendum</a></li></ul></nav></div></details></div><div class=post-content><h2 id=terraform-plugin-framework-custom-types>Terraform Plugin Framework Custom Types<a hidden class=anchor aria-hidden=true href=#terraform-plugin-framework-custom-types>#</a></h2><p>One of the great new things the Terraform Plugin Framework provides is a stronger focus on strict typing and with that, the ability to develop custom types.</p><p>One of the first issues I discovered straight out of the gate when attempting to build a new Terraform Provider with the Plugin Framework was that the data I was modelling for a resource used UUIDs for its record ids. I quickly tried to reach for an equivalent UUID validator in the plugin framework. Unfortunately, the UUID validator hasn&rsquo;t been brought across from SDKv2.
Remembering the benefits the Plugin Framework was supposed to afford us, I started to dig into the custom types.</p><p>When I initially dug into custom types, the Framework was only at v0.14.X and coming back to it almost a year later with the Framework having gone Generally Available (GA) with v1.X.X in February of 2023, there were several improvements and interfaces I needed to update my custom UUID type to use.</p><p>Sidenote: Shout out to Brian Flad (<a href=https://github.com/bflad/terraform-plugin-framework-type-time>bflad</a>) who initially created a custom type for time values while building out the Plugin Framework to see how the interface would look for implementors.</p><h3 id=interface-driven-design>Interface-Driven Design<a hidden class=anchor aria-hidden=true href=#interface-driven-design>#</a></h3><p>The Framework now provides a core-type system that can be extended, which makes a lot more sense and makes fantastic use of Go&rsquo;s composability to reduce the amount of code required.
Pre-<code>v1.X.X</code> types were simply <code>tfsdk</code> Attributes that would then take in your custom type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=s>&#34;id&#34;</span><span class=p>:</span> <span class=nx>tfsdk</span><span class=p>.</span><span class=nx>Attribute</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Required</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Type</span><span class=p>:</span>     <span class=nx>uuidtypes</span><span class=p>.</span><span class=nx>UUIDType</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Potentially previous Validators
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>But now custom types are extended from the Framework&rsquo;s base types, which roughly match the underlying base types that Go (the programming language) provides, so my UUID Type now implements <code>basetypes.StringTypable</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=s>&#34;id&#34;</span><span class=p>:</span> <span class=nx>schema</span><span class=p>.</span><span class=nx>StringAttribute</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>CustomType</span><span class=p>:</span> <span class=nx>uuidtypes</span><span class=p>.</span><span class=nx>UUIDType</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>        <span class=nx>Required</span><span class=p>:</span>   <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>},</span>
</span></span></code></pre></td></tr></table></div></div><p>Surprisingly, once I worked out the new interfaces that were required to implement a <code>basetypes.StringTypable</code>, I was able to remove a lot of my code and migrate the remaining methods to wrap the overloaded methods where my custom type (<code>UUIDType</code> or <code>UUIDValue</code>) was required to be specified.</p><h3 id=maintenance>Maintenance<a hidden class=anchor aria-hidden=true href=#maintenance>#</a></h3><p>Take the following method that implements the <code>attr.Attribute</code> interface that overloads <code>Equal</code> from the composed <code>basetypes.StringType</code> struct.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Equal returns true if the two types are equivalent.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=nx>UUIDType</span><span class=p>)</span> <span class=nf>Equal</span><span class=p>(</span><span class=nx>o</span> <span class=nx>attr</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>other</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>o</span><span class=p>.(</span><span class=nx>UUIDType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>u</span><span class=p>.</span><span class=nx>StringType</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>other</span><span class=p>.</span><span class=nx>StringType</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>While a trivial example of how the new Plugin Framework&rsquo;s composition helps, this means that as the framework grows and new features and methods get added to the base <code>String</code> Type, the maintenance overhead required should be minimised as the base types will, hopefully in most cases, be able to implement upgraded functionality for us for free.</p><p>Rolling up from <code>v0.14.X</code> to <code>v1.X.X</code>, while expected, was a bit of a pain as I was developing on top of a beta framework with many underlying changes expected - Custom Types being one of the last features of the framework to get a look at.
In truth, custom types weren&rsquo;t documented and supported until Terraform Plugin Framework <code>v1.3.X</code>.
The new documentation is fantastic, enabling a developer to easily integrate and extend the Plugin Framework.</p><h2 id=follow-along>Follow Along<a hidden class=anchor aria-hidden=true href=#follow-along>#</a></h2><p>Feel free to follow along with my development at GitHub or chat via my socials:</p><ul><li><a href=https://github.com/matthewhartstonge/terraform-provider-fusionauth>Github - matthewhartstonge/terraform-provider-fusionauth</a></li><li><a href=https://github.com/matthewhartstonge/terraform-plugin-framework-type-uuid>Github - matthewhartstonge/terraform-plugin-framework-type-uuid</a></li><li><a href=https://www.linkedin.com/in/matthewhartstonge/>LinkedIn</a></li><li><a href=https://twitter.com/matthartstonge>Twitter</a></li></ul><h2 id=addendum>Addendum<a hidden class=anchor aria-hidden=true href=#addendum>#</a></h2><ul><li>Time to Code: 6h</li><li>Time to Blog: 1.5h</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.mykro.co.nz/tags/devops/>DevOps</a></li><li><a href=https://blog.mykro.co.nz/tags/go/>Go</a></li><li><a href=https://blog.mykro.co.nz/tags/golang/>Golang</a></li><li><a href=https://blog.mykro.co.nz/tags/programming/>Programming</a></li><li><a href=https://blog.mykro.co.nz/tags/softwaredevelopment/>SoftwareDevelopment</a></li><li><a href=https://blog.mykro.co.nz/tags/softwareengineering/>SoftwareEngineering</a></li><li><a href=https://blog.mykro.co.nz/tags/terraform/>Terraform</a></li><li><a href=https://blog.mykro.co.nz/tags/pluginframework/>PluginFramework</a></li><li><a href=https://blog.mykro.co.nz/tags/customtypes/>CustomTypes</a></li></ul></footer></article></main><footer class=footer><span>© Copyright 2024 Matthew Hartstonge</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>