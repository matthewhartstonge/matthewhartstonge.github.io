<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nginx, Varnish and Wordpress with SSL Termination | Matthew Hartstonge</title><meta name=keywords content="DevOps,Nginx,WordPress,Varnish"><meta name=description content="TL;DR Assuming you&rsquo;ve already got your reverse proxy running, in wp-config.php add the following:
<?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) { // update HTTPS server variable to always 'pretend' incoming requests were // performed via the HTTPS protocol. $_SERVER['HTTPS']='on'; } If you&rsquo;re getting desperate:
// If you ever get stuck, you can override the database set site URIs as well."><meta name=author content="Matthew Hartstonge"><link rel=canonical href=https://blog.mykro.co.nz/posts/2020-07-06-nginx-varnish-wordpress-ssl-termination/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=250"><link rel=icon type=image/png sizes=16x16 href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=16"><link rel=icon type=image/png sizes=32x32 href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=32"><link rel=apple-touch-icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=192"><link rel=mask-icon href="https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=64"><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-3N8ZQ0TS42"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3N8ZQ0TS42",{anonymize_ip:!1})}</script><meta property="og:title" content="Nginx, Varnish and Wordpress with SSL Termination"><meta property="og:description" content="TL;DR Assuming you&rsquo;ve already got your reverse proxy running, in wp-config.php add the following:
<?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) { // update HTTPS server variable to always 'pretend' incoming requests were // performed via the HTTPS protocol. $_SERVER['HTTPS']='on'; } If you&rsquo;re getting desperate:
// If you ever get stuck, you can override the database set site URIs as well."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mykro.co.nz/posts/2020-07-06-nginx-varnish-wordpress-ssl-termination/"><meta property="og:image" content="https://blog.mykro.co.nz/images/wordpress-ssl.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-06T22:13:09+12:00"><meta property="article:modified_time" content="2020-07-06T22:13:09+12:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.mykro.co.nz/images/wordpress-ssl.jpeg"><meta name=twitter:title content="Nginx, Varnish and Wordpress with SSL Termination"><meta name=twitter:description content="TL;DR Assuming you&rsquo;ve already got your reverse proxy running, in wp-config.php add the following:
<?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) { // update HTTPS server variable to always 'pretend' incoming requests were // performed via the HTTPS protocol. $_SERVER['HTTPS']='on'; } If you&rsquo;re getting desperate:
// If you ever get stuck, you can override the database set site URIs as well."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.mykro.co.nz/posts/"},{"@type":"ListItem","position":2,"name":"Nginx, Varnish and Wordpress with SSL Termination","item":"https://blog.mykro.co.nz/posts/2020-07-06-nginx-varnish-wordpress-ssl-termination/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nginx, Varnish and Wordpress with SSL Termination","name":"Nginx, Varnish and Wordpress with SSL Termination","description":"TL;DR Assuming you\u0026rsquo;ve already got your reverse proxy running, in wp-config.php add the following:\n\u0026lt;?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER[\u0026#39;HTTP_X_FORWARDED_PROTO\u0026#39;], \u0026#39;https\u0026#39;) !== false) { // update HTTPS server variable to always \u0026#39;pretend\u0026#39; incoming requests were // performed via the HTTPS protocol. $_SERVER[\u0026#39;HTTPS\u0026#39;]=\u0026#39;on\u0026#39;; } If you\u0026rsquo;re getting desperate:\n// If you ever get stuck, you can override the database set site URIs as well.","keywords":["DevOps","Nginx","WordPress","Varnish"],"articleBody":"TL;DR Assuming you’ve already got your reverse proxy running, in wp-config.php add the following:\n\u003c?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) { // update HTTPS server variable to always 'pretend' incoming requests were // performed via the HTTPS protocol. $_SERVER['HTTPS']='on'; } If you’re getting desperate:\n// If you ever get stuck, you can override the database set site URIs as well. define( 'WP_HOME', 'https://example.com' ); define( 'WP_SITEURL', 'https://example.com' ); // FORCE_SSL_ADMIN is for when you want to secure logins and the admin area so // that both passwords and cookies are never sent in the clear. define( 'FORCE_SSL_ADMIN', true ); Introduction If you are using a reverse proxy that performs SSL termination for you, you may find yourself in a redirect loop or getting a lot of mixed content as Wordpress, quite rightly, acts as if it’s a normal HTTP request.\nPHP uses server variables[1] that scripts can hook into to learn about their world. One of these magic variables, $_SERVER['HTTPS'], is set to a non-empty value if the script was queried through the HTTPS protocol.\nWordpress uses this variable ($_SERVER['HTTPS']) to detect if an incoming request should mutate links, hence leading to a nasty redirect loop when behind a reverse proxy with SSL termination.\n⚠️ Warning! There are a lot of example configuration files ahead!\nArchitecture Overview In order to fix it, we can programmatically make use of that standardised X-Forwarded-Proto header that can be forwarded via a proxy pass configuration in nginx, so we need to configure a few things. In this configuration we have the following architecture:\n+---------------------------+ | | | +-----------+ | | | Varnish | | | +--^----+---+ | | | | | +---------------+ | | | | | Client | | +--+----v-+ | | +--------\u003e| Nginx | | | (ノಠ ∩ಠ)ノ彡 | | +-------+-+ | +---------------+ | | | | | | | +--------v----+ | | | Wordpress | | | +-------------+ | | | | (づ｡◕‿‿◕｡)づ server | | | +---------------------------+ client -\u003e Nginx (https) -\u003e Varnish --(on cache miss)--\u003e Nginx (http) -\u003e wordpress client -\u003e Nginx (https) -\u003e Varnish (on cache hit) nginx (https) -\u003e varnish configuration This configures the client-\u003evarnish flow using SSL termination, but setting a number of X-Forwarded-* headers that we can use to pick up on.\n// /etc/nginx/conf.d/example.com.https.conf # nginx (TLS termination) -\u003e varnish cache server { listen 443 ssl; listen [::]:443 ssl; ## Your website name goes here e.g. example.com *.example.com server_name example.com; server_name_in_redirect off; port_in_redirect off; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; location / { proxy_pass http://varnish; proxy_set_header Host $http_host; proxy_set_header HTTPS \"on\"; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; proxy_set_header X-Forwarded-Port 443; proxy_set_header X-Real-IP $remote_addr; } } upstream varnish { server varnish:80; } varnish -\u003e nginx (http) configuration Thanks to Linode[2] for the reference implementation (which has been extended to add a X-Cache header for tracking cache hits).\n// default.vcl vcl 4.0; sub vcl_hit { set req.http.X-Cache = \"hit\"; } sub vcl_miss { set req.http.X-Cache = \"miss\"; } sub vcl_pass { set req.http.X-Cache = \"pass\"; } sub vcl_pipe { set req.http.X-Cache = \"pipe uncacheable\"; } // Specify that the backend (nginx) is listening on port 8080. // This is our internal backend route to wordpress. backend default { .host = \"nginx\"; .port = \"8080\"; } // Allow cache-purging requests only from the following hosts. acl purger { \"localhost\"; \"127.0.0.1\"; } sub vcl_recv { unset req.http.X-Cache; // Allow cache-purging requests only from the IP addresses in the above acl purger. // If a purge request comes from a different IP address, an error message will be produced. if (req.method == \"PURGE\") { if (!client.ip ~ purger) { return(synth(405, \"This IP is not allowed to send PURGE requests.\")); } return (purge); } // Change the X-Forwarded-For header if (req.restarts == 0) { if (req.http.X-Forwarded-For) { set req.http.X-Forwarded-For = client.ip; } } // Exclude POST requests or those with basic authentication from caching if (req.http.Authorization || req.method == \"POST\") { return (pass); } // Exclude RSS feeds from caching if (req.url ~ \"/feed\") { return (pass); } // Don't cache the WordPress admin and login pages: if (req.url ~ \"wp-admin|wp-login\") { return (pass); } // Remove has_js and CloudFlare/Google Analytics __* cookies and statcounter is_unique set req.http.Cookie = regsuball(req.http.Cookie, \"(^|;\\s*)(_[_a-z]+|has_js|is_unique)=[^;]*\", \"\"); // Remove a \";\" prefix, if present. set req.http.Cookie = regsub(req.http.Cookie, \"^;\\s*\", \"\"); // WordPress sets many cookies that are safe to ignore. set req.http.cookie = regsuball(req.http.cookie, \"wp-settings-\\d+=[^;]+(; )?\", \"\"); set req.http.cookie = regsuball(req.http.cookie, \"wp-settings-time-\\d+=[^;]+(; )?\", \"\"); set req.http.Cookie = regsuball(req.http.Cookie, \"wordpress_test_cookie=[^;]+(; )?\", \"\"); if (req.http.cookie == \"\") { unset req.http.cookie; } } // Cache-purging for a particular page must occur each time we make edits // to that page. sub vcl_purge { set req.method = \"GET\"; set req.http.X-Purger = \"Purged\"; return (restart); } // The sub vcl_backend_response directive is used to handle communication // with the backend server, nginx. We use it to set the amount of time // the content remains in the cache. // We can also set a grace period, which determines how Varnish will serve // content from the cache even if the backend server is down. // - Time can be set in seconds (s), minutes (m), hours (h) or days (d). // Here, we’ve set the caching time to 24 hours, and the grace period to // 1 hour, but you can adjust these settings based on your needs. sub vcl_backend_response { set beresp.ttl = 24h; set beresp.grace = 1h; if (bereq.url !~ \"wp-admin|wp-login|product|cart|checkout|my-account|/?remove_item=\") { unset beresp.http.set-cookie; } } // Change the headers for purge requests. sub vcl_deliver { if (req.http.X-Purger) { set resp.http.X-Purger = req.http.X-Purger; } if (obj.uncacheable) { set req.http.X-Cache = req.http.X-Cache + \" uncacheable\" ; } else { set req.http.X-Cache = req.http.X-Cache + \" cached\" ; } // set X-Cache header in response set resp.http.X-Cache = req.http.X-Cache; } nginx (http) -\u003e wordpress configuration Here we use a generic nginx+php-fpm fastcgi_pass configuration.\n// /etc/nginx/conf.d/example.com.http.conf # nginx (TLS termination) -\u003e varnish cache -\u003e nginx http -\u003e php-fpm server { listen 8080; listen [::]:8080; server_name example.com; server_name_in_redirect off; port_in_redirect off; access_log /var/log/nginx/example.com/access.log; error_log /var/log/nginx/example.com/error.log info; ## Your only path reference. root /var/www/example.com; location = /favicon.ico { log_not_found off; access_log off; } location = /robots.txt { allow all; log_not_found off; access_log off; } # deny running scripts inside writable directories location ~* /(images|cache|media|logs|tmp)/.*\\.(php|pl|py|jsp|asp|sh|cgi)$ { return 403; error_page 403 /403_error.html; } location / { # This is cool because no php is touched for static content. # include the \"?$args\" part so non-default permalinks doesn't break when using query string try_files $uri $uri/ /index.php?$is_args$query_string; } location ~ \\.php$ { try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_intercept_errors on; #NOTE: You should have \"cgi.fix_pathinfo = 0;\" in php.ini include /etc/nginx/fastcgi.conf; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass php-fpm; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log_not_found off; } } upstream php-fpm { server php-fpm:9000; } Forcing ‘Faux’TTPS for PHP (wp-config.php configuration) Woo! Now we have all the above bootstrapped, we can finally grab the X-Forwarded-Proto header that’s been passed along, and force PHP to think that $_SERVER['HTTPS'] = 'on'; by creating an override in wp-config.php[3]\n// wp-config.php \u003c?php /** TLS/HTTPS fixes **/ // in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list // e.g. http,https so check for https existence. if (strpos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) { // update HTTPS server variable to always 'pretend' incoming requests were // performed via the HTTPS protocol. $_SERVER['HTTPS']='on'; } If you get stuck, or redirects are still happening, you can use the site variables to revert to HTTP, or enforce an HTTPS root uri, which will override the database configuration:\n// wp-config.php // If you ever get stuck, you can override the database set site URIs as well. define( 'WP_HOME', 'https://example.com' ); define( 'WP_SITEURL', 'https://example.com' ); Lastly, you can enforce that admin must be visited over HTTPS (FauxTTPS?) by setting FORCE_SSL_ADMIN[4] to stop bad actors trying to jump in over HTTP… ¯\\_(ツ)_/¯\n// wp-config.php // FORCE_SSL_ADMIN is for when you want to secure logins and the admin area so // that both passwords and cookies are never sent in the clear. define( 'FORCE_SSL_ADMIN', true ); Addendum ASCII chart created by: asciiflow Time to SSL Termination frustration: 7+ hours Time to Blog: 1h:39m ","wordCount":"1377","inLanguage":"en","image":"https://blog.mykro.co.nz/images/wordpress-ssl.jpeg","datePublished":"2020-07-06T22:13:09+12:00","dateModified":"2020-07-06T22:13:09+12:00","author":{"@type":"Person","name":"Matthew Hartstonge"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mykro.co.nz/posts/2020-07-06-nginx-varnish-wordpress-ssl-termination/"},"publisher":{"@type":"Organization","name":"Matthew Hartstonge","logo":{"@type":"ImageObject","url":"https://secure.gravatar.com/avatar/0f1d4fae9524fdcf157f93b20a55a1ac?size=250"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.mykro.co.nz/ accesskey=h title="Matthew Hartstonge (Alt + H)">Matthew Hartstonge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.mykro.co.nz/posts title=Blog><span>Blog</span></a></li><li><a href=https://blog.mykro.co.nz/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.mykro.co.nz/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Nginx, Varnish and Wordpress with SSL Termination</h1><div class=post-meta><span title='2020-07-06 22:13:09 +1200 NZST'>July 6, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Matthew Hartstonge</div></header><figure class=entry-cover><a href=https://blog.mykro.co.nz/images/wordpress-ssl.jpeg target=_blank rel="noopener noreferrer"><img loading=lazy src=https://blog.mykro.co.nz/images/wordpress-ssl.jpeg alt="A writer sits at a table with a pencil drawing art with an abstract background containing security iconography"></a></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#architecture-overview aria-label="Architecture Overview">Architecture Overview</a><ul><li><a href=#nginx-https---varnish-configuration aria-label="nginx (https) -&amp;gt; varnish configuration">nginx (https) -> varnish configuration</a></li><li><a href=#varnish---nginx-http-configuration aria-label="varnish -&amp;gt; nginx (http) configuration">varnish -> nginx (http) configuration</a></li><li><a href=#nginx-http---wordpress-configuration aria-label="nginx (http) -&amp;gt; wordpress configuration">nginx (http) -> wordpress configuration</a></li></ul></li><li><a href=#forcing-fauxttps-for-php-wp-configphp-configuration aria-label="Forcing &amp;lsquo;Faux&amp;rsquo;TTPS for PHP (wp-config.php configuration)">Forcing &lsquo;Faux&rsquo;TTPS for PHP (wp-config.php configuration)</a></li><li><a href=#addendum aria-label=Addendum>Addendum</a></li></ul></div></details></div><div class=post-content><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>Assuming you&rsquo;ve already got your reverse proxy running, in <code>wp-config.php</code> add
the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/** TLS/HTTPS fixes **/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list
</span></span></span><span style=display:flex><span><span style=color:#75715e>// e.g. http,https so check for https existence.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strpos</span>($_SERVER[<span style=color:#e6db74>&#39;HTTP_X_FORWARDED_PROTO&#39;</span>], <span style=color:#e6db74>&#39;https&#39;</span>) <span style=color:#f92672>!==</span> <span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// update HTTPS server variable to always &#39;pretend&#39; incoming requests were 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// performed via the HTTPS protocol.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    $_SERVER[<span style=color:#e6db74>&#39;HTTPS&#39;</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;on&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you&rsquo;re getting desperate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#75715e>// If you ever get stuck, you can override the database set site URIs as well.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;WP_HOME&#39;</span>,    <span style=color:#e6db74>&#39;https://example.com&#39;</span> );
</span></span><span style=display:flex><span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;WP_SITEURL&#39;</span>, <span style=color:#e6db74>&#39;https://example.com&#39;</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// FORCE_SSL_ADMIN is for when you want to secure logins and the admin area so
</span></span></span><span style=display:flex><span><span style=color:#75715e>// that both passwords and cookies are never sent in the clear.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;FORCE_SSL_ADMIN&#39;</span>, <span style=color:#66d9ef>true</span> );
</span></span></code></pre></div><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>If you are using a reverse proxy that performs SSL termination for you, you may
find yourself in a redirect loop or getting a lot of mixed content as Wordpress,
quite rightly, acts as if it&rsquo;s a normal HTTP request.</p><p>PHP uses server variables<a href=#php-server-vars>[1]</a> that scripts
can hook into to learn about their world. One of these magic variables,
<code>$_SERVER['HTTPS']</code>, is set to a non-empty value if the script was queried
through the HTTPS protocol.</p><p>Wordpress uses this variable (<code>$_SERVER['HTTPS']</code>) to detect if an incoming
request should mutate links, hence leading to a nasty redirect loop when behind
a reverse proxy with SSL termination.</p><p>⚠️ Warning! There are a lot of example configuration files ahead!</p><h2 id=architecture-overview>Architecture Overview<a hidden class=anchor aria-hidden=true href=#architecture-overview>#</a></h2><p>In order to fix it, we can programmatically make use of that standardised
<code>X-Forwarded-Proto</code> header that can be forwarded via a proxy pass configuration
in nginx, so we need to configure a few things. In this configuration we have
the following architecture:</p><pre tabindex=0><code>            
                                +---------------------------+
                                |                           |
                                |     +-----------+         |
                                |     |  Varnish  |         |
                                |     +--^----+---+         |
                                |        |    |             |
            +---------------+   |        |    |             |
            |    Client     |   |     +--+----v-+           |
            |               +--------&gt;|  Nginx  |           |
            |  (ノಠ ∩ಠ)ノ彡 |   |     +-------+-+           |
            +---------------+   |             |             |
                                |             |             |
                                |    +--------v----+        |
                                |    |  Wordpress  |        |
                                |    +-------------+        |
                                |                           |
                                |   (づ｡◕‿‿◕｡)づ server   |
                                |                           |
                                +---------------------------+

     client -&gt; Nginx (https) -&gt; Varnish --(on cache miss)--&gt; Nginx (http) -&gt; wordpress
                    client -&gt; Nginx (https) -&gt; Varnish (on cache hit)
</code></pre><h3 id=nginx-https---varnish-configuration>nginx (https) -> varnish configuration<a hidden class=anchor aria-hidden=true href=#nginx-https---varnish-configuration>#</a></h3><p>This configures the client->varnish flow using SSL termination, but setting a
number of <code>X-Forwarded-*</code> headers that we can use to pick up on.</p><pre tabindex=0><code>// /etc/nginx/conf.d/example.com.https.conf
# nginx (TLS termination) -&gt; varnish cache
server {
    listen 443 ssl;
    listen [::]:443 ssl;

    ## Your website name goes here e.g. example.com *.example.com
    server_name example.com;
    server_name_in_redirect off;
    port_in_redirect        off;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    location / {
        proxy_pass http://varnish;

        proxy_set_header Host $http_host;
        proxy_set_header HTTPS &#34;on&#34;;
        proxy_set_header X-Forwarded-Host $http_host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Port 443;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

upstream varnish {
    server varnish:80;
}
</code></pre><h3 id=varnish---nginx-http-configuration>varnish -> nginx (http) configuration<a hidden class=anchor aria-hidden=true href=#varnish---nginx-http-configuration>#</a></h3><p>Thanks to Linode<a href=#linode-varnish-wordpress>[2]</a> for the
reference implementation (which has been extended to add a <code>X-Cache</code> header for
tracking cache hits).</p><pre tabindex=0><code>// default.vcl
vcl 4.0;

sub vcl_hit {
    set req.http.X-Cache = &#34;hit&#34;;
}

sub vcl_miss {
    set req.http.X-Cache = &#34;miss&#34;;
}

sub vcl_pass {
    set req.http.X-Cache = &#34;pass&#34;;
}

sub vcl_pipe {
    set req.http.X-Cache = &#34;pipe uncacheable&#34;;
}

// Specify that the backend (nginx) is listening on port 8080.
// This is our internal backend route to wordpress.
backend default {
  .host = &#34;nginx&#34;;
  .port = &#34;8080&#34;;
}

// Allow cache-purging requests only from the following hosts.
acl purger {
  &#34;localhost&#34;;
  &#34;127.0.0.1&#34;;
}

sub vcl_recv {
    unset req.http.X-Cache;

    // Allow cache-purging requests only from the IP addresses in the above acl purger.
    // If a purge request comes from a different IP address, an error message will be produced.
    if (req.method == &#34;PURGE&#34;) {
        if (!client.ip ~ purger) {
            return(synth(405, &#34;This IP is not allowed to send PURGE requests.&#34;));
        }

        return (purge);
    }

    // Change the X-Forwarded-For header
    if (req.restarts == 0) {
        if (req.http.X-Forwarded-For) {
            set req.http.X-Forwarded-For = client.ip;
        }
    }

    // Exclude POST requests or those with basic authentication from caching
    if (req.http.Authorization || req.method == &#34;POST&#34;) {
        return (pass);
    }

    // Exclude RSS feeds from caching
    if (req.url ~ &#34;/feed&#34;) {
        return (pass);
    }

    // Don&#39;t cache the WordPress admin and login pages:
    if (req.url ~ &#34;wp-admin|wp-login&#34;) {
        return (pass);
    }

    // Remove has_js and CloudFlare/Google Analytics __* cookies and statcounter is_unique
    set req.http.Cookie = regsuball(req.http.Cookie, &#34;(^|;\s*)(_[_a-z]+|has_js|is_unique)=[^;]*&#34;, &#34;&#34;);

    // Remove a &#34;;&#34; prefix, if present.
    set req.http.Cookie = regsub(req.http.Cookie, &#34;^;\s*&#34;, &#34;&#34;);

    // WordPress sets many cookies that are safe to ignore.
    set req.http.cookie = regsuball(req.http.cookie, &#34;wp-settings-\d+=[^;]+(; )?&#34;, &#34;&#34;);
    set req.http.cookie = regsuball(req.http.cookie, &#34;wp-settings-time-\d+=[^;]+(; )?&#34;, &#34;&#34;);
    set req.http.Cookie = regsuball(req.http.Cookie, &#34;wordpress_test_cookie=[^;]+(; )?&#34;, &#34;&#34;);
    if (req.http.cookie == &#34;&#34;) {
        unset req.http.cookie;
    }
}

// Cache-purging for a particular page must occur each time we make edits
// to that page.
sub vcl_purge {
    set req.method = &#34;GET&#34;;
    set req.http.X-Purger = &#34;Purged&#34;;
    return (restart);
}

// The sub vcl_backend_response directive is used to handle communication
// with the backend server, nginx. We use it to set the amount of time
// the content remains in the cache.
// We can also set a grace period, which determines how Varnish will serve
// content from the cache even if the backend server is down.
// - Time can be set in seconds (s), minutes (m), hours (h) or days (d).
// Here, we’ve set the caching time to 24 hours, and the grace period to
// 1 hour, but you can adjust these settings based on your needs.
sub vcl_backend_response {
    set beresp.ttl = 24h;
    set beresp.grace = 1h;

    if (bereq.url !~ &#34;wp-admin|wp-login|product|cart|checkout|my-account|/?remove_item=&#34;) {
        unset beresp.http.set-cookie;
    }
}

// Change the headers for purge requests.
sub vcl_deliver {
    if (req.http.X-Purger) {
        set resp.http.X-Purger = req.http.X-Purger;
    }

    if (obj.uncacheable) {
        set req.http.X-Cache = req.http.X-Cache + &#34; uncacheable&#34; ;
    } else {
        set req.http.X-Cache = req.http.X-Cache + &#34; cached&#34; ;
    }

    // set X-Cache header in response
    set resp.http.X-Cache = req.http.X-Cache;
}
</code></pre><h3 id=nginx-http---wordpress-configuration>nginx (http) -> wordpress configuration<a hidden class=anchor aria-hidden=true href=#nginx-http---wordpress-configuration>#</a></h3><p>Here we use a generic nginx+php-fpm fastcgi_pass configuration.</p><pre tabindex=0><code>// /etc/nginx/conf.d/example.com.http.conf
# nginx (TLS termination) -&gt; varnish cache -&gt; nginx http -&gt; php-fpm
server {
    listen 8080;
    listen [::]:8080;

    server_name example.com;
    server_name_in_redirect off;
    port_in_redirect        off;

    access_log  /var/log/nginx/example.com/access.log;
    error_log   /var/log/nginx/example.com/error.log info;

    ## Your only path reference.
    root        /var/www/example.com;

    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    location = /robots.txt {
        allow all;
        log_not_found off;
        access_log off;
    }

    # deny running scripts inside writable directories
    location ~* /(images|cache|media|logs|tmp)/.*\.(php|pl|py|jsp|asp|sh|cgi)$ {
        return          403;
        error_page      403 /403_error.html;
    }

    location / {
        # This is cool because no php is touched for static content.
        # include the &#34;?$args&#34; part so non-default permalinks doesn&#39;t break when using query string
        try_files $uri $uri/ /index.php?$is_args$query_string;
    }

    location ~ \.php$ {
        try_files                   $uri =404;
        fastcgi_split_path_info     ^(.+\.php)(/.+)$;
        fastcgi_intercept_errors    on;

        #NOTE: You should have &#34;cgi.fix_pathinfo = 0;&#34; in php.ini
        include         /etc/nginx/fastcgi.conf;
        fastcgi_index   index.php;
        fastcgi_param   SCRIPT_FILENAME     $document_root$fastcgi_script_name;
        fastcgi_pass    php-fpm;
    }

    location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
        expires max;
        log_not_found off;
    }
}

upstream php-fpm {
    server php-fpm:9000;
}
</code></pre><h2 id=forcing-fauxttps-for-php-wp-configphp-configuration>Forcing &lsquo;Faux&rsquo;TTPS for PHP (wp-config.php configuration)<a hidden class=anchor aria-hidden=true href=#forcing-fauxttps-for-php-wp-configphp-configuration>#</a></h2><p>Woo! Now we have all the above bootstrapped, we can finally grab the
<code>X-Forwarded-Proto</code> header that&rsquo;s been passed along, and force PHP to think that
<code>$_SERVER['HTTPS'] = 'on';</code> by creating an override in <code>wp-config.php</code><a href=#using-reverse-proxy>[3]</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#75715e>// wp-config.php
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/** TLS/HTTPS fixes **/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// in some setups HTTP_X_FORWARDED_PROTO might contain a comma-separated list
</span></span></span><span style=display:flex><span><span style=color:#75715e>// e.g. http,https so check for https existence.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strpos</span>($_SERVER[<span style=color:#e6db74>&#39;HTTP_X_FORWARDED_PROTO&#39;</span>], <span style=color:#e6db74>&#39;https&#39;</span>) <span style=color:#f92672>!==</span> <span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// update HTTPS server variable to always &#39;pretend&#39; incoming requests were 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// performed via the HTTPS protocol.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    $_SERVER[<span style=color:#e6db74>&#39;HTTPS&#39;</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;on&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you get stuck, or redirects are still happening, you can use the site
variables to revert to HTTP, or enforce an HTTPS root uri, which will override
the database configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#75715e>// wp-config.php
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If you ever get stuck, you can override the database set site URIs as well.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;WP_HOME&#39;</span>,    <span style=color:#e6db74>&#39;https://example.com&#39;</span> );
</span></span><span style=display:flex><span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;WP_SITEURL&#39;</span>, <span style=color:#e6db74>&#39;https://example.com&#39;</span> );
</span></span></code></pre></div><p>Lastly, you can enforce that admin must be visited over HTTPS (FauxTTPS?) by
setting <code>FORCE_SSL_ADMIN</code><a href=#force-admin-ssl>[4]</a> to stop bad
actors trying to jump in over HTTP&mldr; <code>¯\_(ツ)_/¯</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#75715e>// wp-config.php
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// FORCE_SSL_ADMIN is for when you want to secure logins and the admin area so
</span></span></span><span style=display:flex><span><span style=color:#75715e>// that both passwords and cookies are never sent in the clear.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>define</span>( <span style=color:#e6db74>&#39;FORCE_SSL_ADMIN&#39;</span>, <span style=color:#66d9ef>true</span> );
</span></span></code></pre></div><h2 id=addendum>Addendum<a hidden class=anchor aria-hidden=true href=#addendum>#</a></h2><ul><li>ASCII chart created by: <a href=http://asciiflow.com/>asciiflow</a></li><li>Time to SSL Termination frustration: 7+ hours</li><li>Time to Blog: 1h:39m</li></ul></div><h2>References</h2><ol><li id=php-server-vars>The PHP Group. (n.d.) <i>"PHP: $_SERVER - Manual."</i> Retrieved July 06, 2020, from <a rel=noopener target=_blank href=https://www.php.net/manual/en/reserved.variables.server.php>https://www.php.net/manual/en/reserved.variables.server.php</a>.</li><li id=linode-varnish-wordpress>Linode. (2019-11-07) <i>"Use Varnish & NGINX to Serve WordPress over SSL & HTTP on Debian 8."</i> Retrieved July 06, 2020, from <a rel=noopener target=_blank href=https://www.linode.com/docs/websites/varnish/use-varnish-and-nginx-to-serve-wordpress-over-ssl-and-http-on-debian-8/>https://www.linode.com/docs/websites/varnish/use-varnish-and-nginx-to-serve-wordpress-over-ssl-and-http-on-debian-8/</a>.</li><li id=using-reverse-proxy>Wordpress. (n.d.) <i>"Administration Over SSL (using a reverse proxy)."</i> Retrieved July 06, 2020, from <a rel=noopener target=_blank href=https://wordpress.org/support/article/administration-over-ssl/#using-a-reverse-proxy>https://wordpress.org/support/article/administration-over-ssl/#using-a-reverse-proxy</a>.</li><li id=force-admin-ssl>Wordpress. (n.d.) <i>"Administration Over SSL (force ssl logins and ssl admin access)."</i> Retrieved July 06, 2020, from <a rel=noopener target=_blank href=https://wordpress.org/support/article/administration-over-ssl/#to-force-ssl-logins-and-ssl-admin-access>https://wordpress.org/support/article/administration-over-ssl/#to-force-ssl-logins-and-ssl-admin-access</a>.</li></ol><footer class=post-footer><ul class=post-tags><li><a href=https://blog.mykro.co.nz/tags/devops/>DevOps</a></li><li><a href=https://blog.mykro.co.nz/tags/nginx/>Nginx</a></li><li><a href=https://blog.mykro.co.nz/tags/wordpress/>WordPress</a></li><li><a href=https://blog.mykro.co.nz/tags/varnish/>Varnish</a></li></ul></footer></article></main><footer class=footer><span>© Copyright 2023 Matthew Hartstonge</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>